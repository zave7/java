--DDL data definition language

-- char 고정길이 max 2000 byte
-- varchar2는 가변길이 max 4000 byte

-- ksc5601 - euc-kr 한글 2byte

-- utf 유니코드 전세계 모든문자 표현 한글 3byte
-- 오라클에서 long 타입은 검색속도 느리다고함
-- LOB large object , blob(binary) clob(charactor) max 4GB
-- db에는 가벼운 파일을 저장함
-- 일반적으로 타임스탬프보다 데이트를 많이 쓴다

-- 회원 member (필수)

-- 이름            name        varchar2(30)
-- 아이디          id          varchar2(16)
-- 비밀번호        pass        varchar(16)
-- 나이            age         number(3)
-- 이메일아이디    emailid     varchar(30)
-- 이메일도메인    emaildomain varchar(30)
-- 가입일          joindate    date

create table member (
    name varchar2(30) not null,
    id varchar2(16) ,
    pass varchar2(16) not null,
    age number(3) check (age < 150),
    emailid varchar2(30),
    emaildomain varchar2(30),
    joindate date default sysdate,
    
    constraint member_id_pk primary key (id) -- constraint 제약 조건 거는 방법
); --테이블에 제약조건이 많으면 별로 좋지않다

DROP table member; -- member table 을 제거
DROP table member_detail;



-- 회원       member_detail상세정보

-- 아이디       id              varchar(16)
-- 우편번호     zipcode         varchar2(5) 숫자앞에 0을 못붙임
-- 일반주소     address         varchar(100)
-- 상세주소     address_detail  varchar(100)
-- 전화번호     tel1            varchar(3)
-- 전화번호2    tel2            varchar(4)
-- 전화번호3    tel3            varchar(4)

create table member_detail (
    id varchar2(16),
    zipcode varchar2(5),
    address varchar2(100),
    address_detail varchar2(100),
    tel1 varchar2(3),
    tel2 varchar2(4),
    tel3 varchar2(4),
    
    constraint member_detail_id_fk foreign key (id)
    references member (id) -- 외래키 제약 조건 거는 방법
);

create table emp_all --table 구문에도 서브쿼리 가능
    as 
    SELECT * 
    FROM employees;
    
SELECT * 
FROM emp_all;

create table emp_blank --테이블 구조만 가져오고 싶을 경우 이런 방법으로 가능
    AS
    SELECT *
    FROM employees
    WHERE 1=0;
SELECT *
FROM emp_blank;

create table emp_50 --특정한 컬럼과 임의이 컬럼 이름을 지정해서 만들 수 있다
    AS
    SELECT employee_id eid, first_name name, salary sal, d.department_name dname
    FROM employees e, departments d
    WHERE e.department_id = 50
    AND e.department_id = d.department_id;

SELECT *
FROM emp_50;

--DML
--INSERT
INSERT INTO member
VALUES ('권영찬','zave','1234',23,'zave7','naver.com', sysdate);

INSERT INTO member
VALUES ('zave1','김영찬','1234',149,'zave7','naver.com', sysdate);

INSERT INTO member (id, name, age, pass, emailid, emaildomain, joindate)
VALUES ('zave1','김영찬','123',149,'zave7','naver.com', sysdate);

INSERT INTO member (id, name, pass, joindate)
VALUES ('zave2','김영찬',149, sysdate);

SELECT *
FROM member;

INSERT INTO member_detail
VALUES ('zave', '12345', '인천광역시 서구', '무지개빌라', 010, 7777, 1234);

INSERT INTO member_detail 
VALUES ('zave2', '12445', '서울', '홍은동', '010', '1277', '1212');

INSERT INTO member_detail 
VALUES ('zave3', '12445', '서울', '홍은동', '010', '1277', '1212');


INSERT INTO member (id, name, age, pass, emailid, emaildomain, joindate)
VALUES ('oracle', '오라클', '30', 'a1234567', 'oracle', 'oracle.com', sysdate);

INSERT INTO member_detail (id, zipcode, address, address_detail, tel1, tel2, tel3) 
VALUES ('oracle', '12345', '부산 광역시', '오라클동', '010', '1111', '2222');

INSERT ALL --insert 한번에 여러번
    INTO member (id, name, age, pass, emailid, emaildomain, joindate)
    VALUES ('oracle', '오라클', '30', 'a1234567', 'oracle', 'oracle.com', sysdate)
    INTO member_detail (id, zipcode, address, address_detail, tel1, tel2, tel3) 
    VALUES ('oracle', '12345', '부산 광역시', '오라클동', '010', '1111', '2222')
SELECT * --insert all 다음에는 select 가 나와야 한다.
FROM dual;

SELECT *
FROM member m, member_detail md
WHERE m.id = md.id;


commit;

SELECT *
FROM tab;
-- 테이블을 drop 하면 바로 지워지지 않고 bin 에 박아버린다

purge recyclebin; -- bin 에 있는 드랍했던 테이블들을 완전히 삭제

SELECT *
FROM emp_blank; -- 테이블 구조를 카피 할때 제약조건까지 모두 복사한다

-- subquery 를 이용한 insert 
INSERT INTO emp_blank
SELECT *
FROM employees
WHERE department_id = 80;

SELECT *
FROM employees
WHERE department_id = 80;

-- 100번 사원의 사번, 이름, 직책, 부서전호
-- emp_blank
INSERT INTO emp_blank (employee_id, first_name, last_name, email, hire_date, job_id, department_id)
SELECT employee_id, first_name, last_name, email, hire_date, job_id, department_id
FROM employees
WHERE employee_id = 100;

SELECT employee_id, first_name, job_id, department_id
FROM employees
WHERE employee_id = 100;

drop table emp_all;
drop table emp_blank;
drop table emp_50;

create table emp_blank -- 테이블 구조만 가져오고 싶을 경우 이런 방법으로 가능
    AS
    SELECT *
    FROM employees
    WHERE 1=0;
    
SELECT *
FROM emp_blank;

-- update
-- update 는 항상 WHERE 조건을 달고 다니자

SELECT *
FROM member;
commit;
rollback;

UPDATE member
SET pass = 9876;

UPDATE member
SET pass = 9876
WHERE id = '3oracle';

-- 자바2의 비번을 1234로 나이 25 변경
UPDATE member
SET pass = '1234', age = 25
WHERE id = '3oracle';

-- 3oracle의 비번을 5678로 나이는 아이디가 oracle인 사람과 같게 변경
UPDATE member
SET pass = '5678', age = (SELECT age FROM member WHERE id = 'oracle')
WHERE id = '3oracle';

UPDATE member
SET id = 'java2'
WHERE id = '3oracle';

-- DELETE 
-- from 있어도 되고 없어도 된다
-- delete 는 delete all 이 없다
DELETE member_detail WHERE id = 'java2';
DELETE member WHERE id = 'java2';
SELECT *
FROM member;
--자바에서 배치를 이용해 한번의 커넥션으로 해결 가능

-- merge !!! 쓸만할 때가 있어요
drop table product;
create table product (
    pid number,
    pname varchar2(10),
    cnt number,
    price number,
    constraint product_pid_pk primary key (pid)
    );
    
INSERT INTO product (pid, pname, cnt, price)
values (100, '새우깡', 100, 1500);
INSERT INTO product (pid, pname, cnt, price)
values (200, '감자깡', 80, 2000);
INSERT INTO product (pid, pname, cnt, price)
values (300, '고구마깡', 120, 3000);
select *
from product;

-- 상품코드가 400인 자갈치 1200원 150 개 입고

merge INTO product 
using dual
on (pid = 400)
when matched then 
update set cnt = cnt + 150
when not matched then
insert (pid, pname, cnt, price) values (400, '자갈치', 150, 1200);

merge INTO product 
using dual
on (pid = 100)
when matched then 
update set cnt = cnt +50
when not matched then
insert (pid, pname, cnt, price) values (100, '새우깡', 50, 1500);

-- 상품 코드가 100번인 새우깡 1500원 50개 입고


-- transaction --작업의 단위
SELECT *
FROM product;

update product 
set cnt = 800 
where pid=100;

commit;

rollback;
-- rollback 할 지짐 포인트를 설정 savepoint 변수명;
INSERT INTO product 
VALUES ('101', '꿍1', 501, 12001);

INSERT INTO product 
VALUES ('102', '꿍2', 502, 12002);

INSERT INTO product 
VALUES ('103', '꿍3', 503, 12003);

savepoint a;

INSERT INTO product 
VALUES ('104', '꿍4-1', 504, 12004);

INSERT INTO product 
VALUES ('105', '꿍5', 505, 12005);

savepoint b;

INSERT INTO product 
VALUES ('106', '꿍6', 506, 12006);

INSERT INTO product 
VALUES ('107', '꿍7', 507, 12007);

SELECT *
FROM product;

rollback to b;

-- sequence
-- 시퀀스는 오브젝트이다 오브젝트 레벨은 커밋 롤백 불가
-- commit, rollback은 DML에서만 가능

CREATE SEQUENCE product_pid_seq
start with 1 increment by 1;
SELECT *
FROM product;

delete product;
commit;

INSERT INTO product (pid, pname, cnt, price)
VALUES (product_pid_seq.nextval, '이름', 10, 1000);

--하나의 쿼리에서 nextval은 여러번 안됌
SELECT product_pid_seq.nextval, product_pid_seq.nextval, product_pid_seq.currval  --코드 사용이 되면 증가된다
FROM dual;

SELECT 
    product_pid_seq.currval
FROM dual;

rollback;

--일단 마무리

--숫자 함수
SELECT  1234.6438, 
        round(1234.6438), 
        round(1234.6438, 1), 
        round(1234.6438, -1), -- 반올림
        round(1234.6438, 3), 
        round(1234.6438,-3)
        
FROM    dual;
SELECT round(1616.1616)
FROM dual;
--내림 제거
SELECT  1234.6438, 
        trunc(1234.6438), 
        trunc(1234.6438, 1), 
        trunc(1234.6438, -1), 
        trunc(1234.6438, 3), 
        trunc(1234.6438,-3)
        
FROM    dual;
SELECT TRUNC (1616.1616)
FROM dual;
--소수점 제거 후 가장 작은 정수 변환
SELECT  1234.5438, 
        floor(1234.5438)
        
FROM    dual;

--소수점 제거 후 가장 큰 정수 변환
SELECT  CEIL(123.1234)
FROM    dual;

--나머지 연산
SELECT  1+3, 
        MOD(17,5) 
        
FROM    dual;
SELECT MOD((1+3)/2,2)
FROM dual;
--절댓값
SELECT  abs(-1234)
FROM    dual;

--문제
-- 사원의 사번, 이름, 급여, 커미션포함급여
-- 커미션 포함 급여는 100의 자리수로 표현(반올림)
SELECT  employee_id, 
        first_name, 
        salary, 
        round(salary + (salary * nvl(commission_pct, 0)), -2)
        
FROM    employees;
SELECT nvl2(7, 1, 0)
FROM dual;

--문자 함수
SELECT  'kiTRi', 
        lower('kiTRi'), 
        upper('kiTRi'), 
        initcap('kiTRi'), 
        length('kiTRi')
        
FROM    dual;

SELECT  employee_id, 
        first_name || ' '|| last_name, 
        CONCAT(first_name || ' ', last_name)
        
FROM    employees;

SELECT  CONCAT(first_name, CONCAT(' ', last_name)) 
FROM    employees; 

--데이터베이스의 인덱스는 1부터, instr 얘도 많이쓴다고함
SELECT  'hello oracle', substr('hello oracle', -4,7), 
        substr('hello oracle', 3)
        
FROM    dual; 

SELECT  'hello oracle', substr('hello oracle', 1), 
        instr('hello oracle', 'o', 6)
        
FROM    dual; 

--'123-456' zipcode
SELECT  '12345-67' zipcode, 
        substr('12345-67', 1, (instr('12345-67', '-')-1)) zip1, 
        substr('12345-67', (instr('12345-67', '-')+1)) zip2
        
FROM    dual;
-- '-' 2개일 때
SELECT  '010-34-568' pnum, 
        substr('010-34-568', 1, (instr('010-34-568', '-')-1)) pnum1, 
        substr('010-34-568', instr('010-34-568', '-') +1 , (instr('010-34-568', '-', (instr('010-34-568', '-')+1)) - instr('010-34-568', '-')-1)) pnum2,
        substr('010-34-568', (instr('010-34-568', '-', instr('010-34-568', '-')+1)+1)) pnum3
        
FROM    dual;

--주로 커맨드 라인에서 가독성을 높이기 위해 LPAD, RPAD를 사용함trim 도

--날짜함수
SELECT  sysdate +3, 
        sysdate -3, 
        to_char(sysdate + 3 / 24, 'yyyy-hh-mm hh24:mi:ss') --날짜에 계산은 일 단위로 + -
        
FROM    dual;




SELECT  sysdate,                                
        months_between(sysdate, sysdate + 70),  -- 개월차이를 리턴 +day 
        next_day(sysdate, 3),                   -- 오늘 기준으로 다음 요일 날짜를 리턴(1,2,3,4,5,6,7)
        add_months(sysdate, 6),                 -- 개월을 추가
        last_day(sysdate)                       -- 월의 마지막 날짜를 리턴
        
FROM    dual;
SELECT sysdate - to_date('19/03/06')
FROM dual;

-- yyyy 2019
-- yy 19
-- mm 02
-- mon 2월 2jau
-- w 월 주차
-- ww 년 주차
-- d 요일
-- dd 일
-- ddd 년 중 일
-- dy 월 mon
-- day 월요일 monday
SELECT sysdate, to_char(sysdate, 'yyyy yy mm mon month w ww d dd ddd dy day')
FROM dual;
-- pm hh 
-- am hh
-- hh 
-- mi 
-- ss
SELECT sysdate, to_char(sysdate, 'am hh hh24 mi ss')
FROM dual;

-- 날짜 반올림
SELECT  to_char(sysdate, 'yyyy.mm.dd hh24:mi:ss'),
        to_char(round(sysdate), 'yyyy.mm.dd hh24:mi:ss'),
        to_char(round(sysdate, 'mm'), 'yyyy.mm.dd hh24:mi:ss'),
        to_char(round(sysdate, 'yy'), 'yyyy.mm.dd hh24:mi:ss'),
        to_char(round(sysdate, 'hh'), 'yyyy.mm.dd hh24:mi:ss'),
        to_char(round(sysdate, 'mi'), 'yyyy.mm.dd hh24:mi:ss')
        
FROM dual
union
SELECT  to_char(sysdate, 'yyyy.mm.dd hh24:mi:ss'),
        to_char(trunc(sysdate), 'yyyy.mm.dd hh24:mi:ss'),
        to_char(trunc(sysdate, 'mm'), 'yyyy.mm.dd hh24:mi:ss'),
        to_char(trunc(sysdate, 'yy'), 'yyyy.mm.dd hh24:mi:ss'),
        to_char(trunc(sysdate, 'hh'), 'yyyy.mm.dd hh24:mi:ss'),
        to_char(trunc(sysdate, 'mi'), 'yyyy.mm.dd hh24:mi:ss')
        
FROM dual;

-- 자료형 변환 함수
-- to_char, to_number, to_date
-- 오라클의 사칙연산은 산술연산밖에 되지 않는다(자동 형변환 가능) ||가 있으니
SELECT 'a', 3, '3', 3 + 5, '3' + 5
FROM dual;

SELECT  1123456.789,
        to_char(1123456.789, 'L0,000,000,000.00'), -- 남은 공간을 0으로 채움
        to_char(1123456.789, '$9,999,999,999.99')  -- 남은 공간을 공백으로 채움
FROM dual;
 
SELECT '123,456,98', length(to_char(to_number('123,456.98', '000000.00'))) "t"
FROM dual;

SELECT  sysdate, to_char(sysdate, 'yy.mm.dd w ww dy day pm mon month ddd'),
        to_char(sysdate, 'hh:mi:ss'),
        to_char(sysdate, 'hh24:mi:ss')
FROM dual;

--20190225142154 >> 날짜 >> 3일후
SELECT to_char(to_date(to_char(20190225142154, '00000000000000'), 'yyyymmddhh24miss') +3, 'yyyy-mm-dd hh24:mi:ss')
FROM dual;

SELECT to_char(to_date(to_char(20190225142154), 'yyyymmddhh24miss') + 3, 'yyyy--mm-dd hh24:mi:ss')
FROM dual;

--일반함수
--급여가 4000미만인 사원은 저연봉
--  10000미만 평균연봉
-- 10000이상 고연봉
--  사번, 이름, 급여, 연봉등급
SELECT nvl2(commission_pct, 1, 2)
FROM employees;
SELECT employee_id, first_name, salary, 
    case 
        when salary < 4000
        then '저연봉'
        when salary < 10000
        then '평균연봉'
        else '고연봉'
    end 연봉등급
FROM employees
ORDER BY salary desc;
SELECT nvl2(department_id, -0, 1) FROM employees;
SELECT employee_id, 
    case 
        when commission_pct is not null
        then '커미션 있음!!'
        else '  커미션 없음'
    end 커미션여부
FROM employees;
SELECT salary 급여
FROM employees;

--사원구분
--1980년도 입사 임원
-- 90 평사원
-- 2000 신입사원
--사번,이름,입사일,사원구분

SELECT  employee_id 사번, first_name 이름 , hire_date 입사일, 

    case
        when to_number(to_char(hire_date, 'yyyy'), '0000') < 1990 
        then '임원'
        when to_number(to_char(hire_date, 'yyyy'), '0000') < 2000
        then '평사원'
        else '신입사원'
    end 사원구분
    
FROM employees;

SELECT ascii('0') || ' 48', ascii('A') || ' 65', ascii('a') || ' 97'
FROM dual;

SELECT case when 'abc'<'abd' then '작다'
end 비교
FROM dual;

SELECT chr(48)
FROM dual;

--문제 
--사번, 이름, 핸드폰번호, 입사월홀짝, 입사년도일수
SELECT to_char(hire_date, 'ddd') 
FROM employees;
SELECT * from employees;
SELECT  phone_number, 
        substr('010-34568-1234-4321', 1, (instr('010-34568-1234-4321', '-')-1)) pnum1,
        case
            when instr('010-34568-1234-4321', '-', (instr('010-34568-1234-4321', '-')+1)) !=0
            then substr('010-34568-1234-4321', instr('010-34568-1234-4321', '-') +1 , (instr('010-34568-1234-4321', '-', (instr('010-34568-1234-4321', '-')+1)) - instr('010-34568-1234-4321', '-')-1))
            else 'x'
        end pnum2,
        case 
            when instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-')+1)+1) !=0
            then substr('010-34568-1234-4321', instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-')+1)+1 , instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-')+1)+1) - (instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-')+1)+1))
            else 'x'
        end pnum3,
        case 
            when instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-')+1)+1)+1) !=0
            then substr('010-34568-1234-4321', instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-')+1)+1))
            else 'x'
        end pnum4
FROM employees;

    SELECT instr('010-34568-1234-1234', '-', instr('010-34568-1234-1234', '-', instr('010-34568-1234-1234', '-')+1)+1) - (instr('010-34568-1234-1234', '-', instr('010-34568-1234-1234', '-')+1)+1)
    from dual;
    SELECT instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-', instr('010-34568-1234-4321', '-')+1)+1)+1)
    FROM dual;
SELECT  '010-34-568' pnum, 
        substr('010-34-568', 1, (instr('010-34-568', '-')-1)) pnum1, 
        substr('010-34-568', instr('010-34-568', '-') +1 , (instr('010-34-568', '-', (instr('010-34-568', '-')+1)) - instr('010-34-568', '-')-1)) pnum2,
        substr('010-34-568', (instr('010-34-568', '-', instr('010-34-568', '-')+1)+1)) pnum3
        
FROM    dual;

--부서이름이 'IT'에 근무하는 사원의 사번, 이름, 급여

SELECT  e.employee_id, e.first_name, e.salary
FROM    employees e, departments d
WHERE   e.department_id = d.department_id
AND     lower(d.department_name) = lower('IT');

--조인을 했을때 안좋은점 카테시안 프로덕트를 하고 뽑아오기 때문에
--데이터의 양이 많으면 비효율적

SELECT  employee_id, first_name, salary
FROM    employees
WHERE   lower(d.department_name) = lower('IT');
--
SELECT  department_id 
FROM    departments
WHERE   department_name = 'IT';
--
SELECT  employee_id, first_name, salary
FROM    employees
WHERE   department_id = 60;

--가독성을 높이자
SELECT  employee_id, first_name, salary
FROM    employees
WHERE   department_id =     (SELECT department_id 
                            FROM departments
                            WHERE department_name = 'IT'
                            );

--'Seattle' 에 근무하는 사원의 사번, 이름, 급여
SELECT  employee_id, first_name, salary
FROM    employees
WHERE   department_id in    ((SELECT department_id
                            FROM departments
                            WHERE location_id =     (SELECT l.location_id
                                                    FROM locations l
                                                    WHERE l.city = 'Seattle')));
--
SELECT  location_id
FROM    locations
WHERE   city = 'Seattle';
--
SELECT  department_id
FROM    departments
WHERE   location_id =   (SELECT location_id
                        FROM locations
                        WHERE city = 'Seattle');
--
SELECT  employee_id, first_name, salary
FROM    employees
WHERE   department_id in    ((SELECT department_id
                            FROM departments
                            WHERE location_id =     (SELECT location_id
                                                    FROM locations
                                                    WHERE city = 'Seattle')));

-- join + subquery
SELECT  e.employee_id, 
        e.first_name, 
        e.salary, 
        d.department_name
        
FROM    employees e, 
        departments d
        
WHERE   e.department_id = d.department_id

AND     d.location_id =     (SELECT location_id
                            FROM locations
                            WHERE city = 'Seattle');

--지역번호가 1700인 부서에서 일하는 사원의
-- 사번, 이름, 부서번호 ,부서이름
--160행을 조합한다
SELECT  e.employee_id, 
        e.first_name, 
        e.department_id, 
        d.department_name
        
FROM    employees e, departments d
WHERE   e.department_id = d.department_id
AND     d.location_id = 1700;

--인라인 뷰 라는 명칭으로 불린다.
SELECT e.employee_id, e.first_name, e.department_id, d.department_name
FROM employees e,   (SELECT department_id, department_name
                    FROM departments
                    WHERE location_id = 1700) d
                    
WHERE e.department_id = d.department_id;

SELECT department_id, department_name
FROM departments
WHERE location_id = 1700;

--'Kevin' 보다 급여를 많이 받는 사원의 사번, 이름, 급여
SELECT employee_id, first_name, salary
FROM employees
WHERE salary >  (SELECT salary
                FROM employees 
                WHERE first_name = 'Kevin');
-- 50번 부서에 있는 사원들 보다 급여를 많이 받는 사원의 사번, 이름, 급여
SELECT employee_id, first_name, salary
FROM employees
WHERE salary > all (SELECT salary FROM employees WHERE department_id = 50);

-- 부서에 근무하는 모든 사원들의 평균 급여보다 많이 받는 사원의 사번, 이름, 급여
-- 상호관련서브쿼리
SELECT employee_id, first_name, salary
FROM employees
WHERE salary >  (SELECT avg(salary) 
                FROM employees 
                WHERE department_id is not null);
                
-- 각 사원의 같은 부서에 근무하는 사원들의 평균 급여보다 많이 받는 사원의 사번, 이름, 급여
-- 부서가 없는 사람은 출력하지 않는다
SELECT employee_id, first_name, salary
FROM employees;

SELECT round(avg(salary), 2) "asal", department_id
FROM employees
GROUP BY department_id;

SELECT e.employee_id, e.first_name, e.salary, d.asal, d.department_id
FROM employees e,   (SELECT avg(salary) asal, department_id
                    FROM employees
                    GROUP BY department_id) d
WHERE e.department_id = d.department_id
AND e.salary > d.asal
ORDER BY d.department_id;

--부서번호가 20번의 평균 급여보다 크고, 
--매니저가 있는 사원으로 부서 번호가 20이 아닌 사원의
--사번, 이름, 급여, 부서번호

SELECT employee_id, first_name, salary, department_id
FROM employees
WHERE salary >  (SELECT avg(salary)
                FROM employees
                WHERE department_id = 20)
AND manager_id is not null
AND department_id != 20;

--부서번호가 20번의 평균 급여보다 크고, 
--매니저인 사원으로 부서 번호가 20이 아닌 사원의
--사번, 이름, 급여, 부서번호
SELECT e.employee_id, e.first_name, e.salary, e.department_id
FROM employees e,    (SELECT employee_id
                    FROM employees e
                    WHERE salary >  (SELECT avg(salary)
                                    FROM employees
                                    WHERE department_id = 20)) d
WHERE d.employee_id = e.manager_id;
--
SELECT e20.employee_id, e20.first_name, e20.salary, e20.department_id
FROM    (SELECT distinct manager_id 
        FROM employees
        WHERE manager_id is not null) m, 
        (SELECT employee_id, 
                first_name, 
                salary, 
                department_id
        FROM employees
        WHERE salary >  (SELECT avg(salary)
                        FROM employees
                        WHERE department_id = 20)) e20
WHERE m.manager_id = e20.employee_id
AND department_id != 20;
--
SELECT e20.employee_id, e20.first_name, e20.salary, e20.department_id
FROM     
        (SELECT employee_id, 
                first_name, 
                salary, 
                department_id
        FROM employees
        WHERE salary >  (SELECT avg(salary)
                        FROM employees
                        WHERE department_id = 20)) e20
WHERE e20.employee_id = (SELECT distinct manager_id 
                        FROM employees
                        WHERE manager_id is not null)
AND department_id != 20;

--부서번호가 20번의 평균 급여보다 크고, 
--부서장 사원으로 부서 번호가 20이 아닌 사원의
--사번, 이름, 급여, 부서번호
SELECT  e.employee_id, 
        e.first_name, 
        e.salary, 
        e.department_id
FROM    employees e, departments d
WHERE   salary >    (SELECT avg(salary)
                    FROM employees
                    WHERE department_id = 20)
AND     e.employee_id = d.manager_id
AND     e.department_id != 20;

SELECT  *
FROM    departments;

--20번 부서의 평균급여
--50번 부서의 급여총합
--80번 부서의 인원수

--scala 서브쿼리에는 단일 행, 단일 컬럼만 올 수 있다.
--스칼라 서브쿼리란 Select-List에서 서브쿼리가 사용될 때 이를 스칼라 서브쿼리라 칭함.
--스칼라 서브쿼리의 특징은 다음과 같음.
--하나의 레코드만 리턴이 가능하며, 두개 이상의 레코드는 리턴할 수 없다.
--일치하는 데이터가 없더라도 NULL값을 리턴할 수 있다.
--이는 원래 그룹함수의 특징중에 하나인데 스칼라 서브쿼리 또한 이 특징을 가지고 있다.

--그룹함수의 특징을 가지고있음
SELECT  (SELECT AVG(salary) FROM employees WHERE department_id = 20) "20번 부서 평균 급여",
        (SELECT SUM(salary) FROM employees WHERE department_id = 50) "50번 부서 급여총합",
        (SELECT COUNT(*) FROM employees WHERE department_id = 80) "80번 부서의 인원수"
FROM    dual;

--모든 사원, 사번, 이름, 급여 등급, 부서이름
--단, A는 1등급, B는 2등급 ... F는 6등급

SELECT  e.employee_id, 
        e.first_name, 
        e.salary, 
        decode(jg.grade_level, 'A','1등급',
                            'B','2등급',
                            'C','3등급',
                            'D','4등급',
                            'E','5등급',
                            'F','6등급') "급여등급",
        d.department_name
FROM    employees e, departments d, job_grades jg 
WHERE   e.department_id = d.department_id(+)
AND     e.salary between jg.lowest_sal and jg.highest_sal
ORDER BY e.salary desc;
--
SELECT  e.employee_id, d.department_name,
        e.first_name, 
        e.salary,
        case
            when (SELECT grade_level FROM job_grades WHERE e.salary between lowest_sal and highest_sal) = 'A'
            then '1등급'
            when (SELECT grade_level FROM job_grades WHERE e.salary between lowest_sal and highest_sal) = 'B'
            then '2등급'
            when (SELECT grade_level FROM job_grades WHERE e.salary between lowest_sal and highest_sal) = 'C'
            then '3등급'
            when (SELECT grade_level FROM job_grades WHERE e.salary between lowest_sal and highest_sal) = 'D'
            then '4등급'
            when (SELECT grade_level FROM job_grades WHERE e.salary between lowest_sal and highest_sal) = 'E'
            then '5등급'
            when (SELECT grade_level FROM job_grades WHERE e.salary between lowest_sal and highest_sal) = 'F'
            then '6등급'
            else '등급에 없음'
        end 급여등급
FROM employees e, departments d
WHERE e.department_id = d.department_id;
--
SELECT  e.employee_id, d.department_name,
        e.first_name, 
        e.salary,
        decode((SELECT grade_level FROM job_grades WHERE e.salary between lowest_sal and highest_sal),
            'A','1등급','B','2등급','C','3등급','D','4등급','E','5등급','F','6등급')
FROM employees e, departments d
WHERE e.department_id = d.department_id;
SELECT *
FROM job_grades;
--ORDER BY 절에도 서브쿼리 가능
--GROUP BY 에도 가능

--사번, 이름, 경력(n년 m개월), 급여등급, 급여순위
SELECT  e.employee_id, e.first_name, concat(to_char(trunc(months_between(sysdate,e.hire_date)/12)), '개월'),
        (SELECT count(employee_id) FROM employees WHERE e.salary > salary)
FROM employees e;

-- 모든 사원의 사번, 이름, 급여, 급여등급

SELECT employee_id, first_name, salary, 
    case 
        when salary between 1000 and 2999
        then 'A'
        when salary between 3000 and 5999
        then 'B'
        when salary between 6000 and 9999
        then 'C'
        when salary between 10000 and 14999
        then 'D'
        when salary between 15000 and 24999
        then 'E'
        when salary between 25000 and 40000
        then 'F'
    end 급여등급
FROM employees e
ORDER BY 급여등급;
SELECT *
FROM job_grades;
-- non-equi join

SELECT e.employee_id, e.first_name, e.salary, jg.grade_level
FROM employees e, job_grades jg
WHERE salary >= jg.lowest_sal 
and salary <= jg.highest_sal;

SELECT *
FROM employees e, job_grades jg
WHERE salary between jg.lowest_sal and jg.highest_sal;

--outer join
--모든 사원의 사번, 이름, 부서번호, 부서이름
--단,부서가 미지정일 경우 부서이름을 '대기발령중'
SELECT e.employee_id, e.first_name, d.department_id, nvl(d.department_name, '대기발령중')
FROM employees e, departments d
WHERE e.department_id = d.department_id(+);

SELECT *
FROM employees
WHERE department_id is null;

-- 모든 사원의 사번, 이름, 상관사번, 상관이름
-- 단, 상관이 없을 경우 상관이름에 '사장'으로 출력

SELECT e.employee_id, e.first_name, e.manager_id, nvl(m.first_name,'사장')
FROM employees e, employees m
WHERE e.manager_id = m.employee_id(+);

-- 모든 사원의 사번, 이름, 상관사번, 상관이름, 부서이름
-- 단, 상관이 없을 경우 상관이름에 '사장'으로 출력
-- 단, 부서가 미지정일 경우 부서이름을 '대기발령중'으로 출력
SELECT  e.employee_id, 
        e.first_name, 
        e.manager_id, 
        nvl(m.first_name, '사장'), 
        nvl(d.department_name, '대기발령중')
FROM employees e, employees m, departments d
WHERE e.manager_id = m.employee_id(+)
and e.department_id = d.department_id(+);

--ANSI JOIN 표준

SELECT * 
FROM employees, departments;

SELECT * 
FROM employees CROSS JOIN departments;

--사번, 이름, 부서이름
SELECT e.employee_id, e.first_name, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id;

--INNER JOIN

--INNER JOIN 이너 조인은 INNER를 빼도 된다(default)
--on은 조인조건만 기술하는 키워드
--조건은 WHERE 절에
SELECT e.employee_id, e.first_name, d.department_name
FROM employees e INNER JOIN departments d
ON e.department_id = d.department_id
WHERE e.department_id = 50;

SELECT e.employee_id, e.first_name, d.department_name
FROM employees e JOIN departments d
ON e.department_id = d.department_id
WHERE e.department_id = 50;

--USING을 쓸 때는 테이블의 조인조건을 걸 컬럼명이 동일해야한다.
--WHERE 에는 별칭을 붙여 식별할 필요가 없다
SELECT e.employee_id, e.first_name, d.department_name
FROM employees e JOIN departments d
USING (department_id)
WHERE department_id = 50;

--NUTURAL JOIN 모든 동일 컬럼을 이용해 조인을 한다
--그렇기 때문에 동일컬럼이 1개인경우에만 사용하는게 좋다
SELECT e.employee_id, e.first_name, d.department_name
FROM employees e NATURAL JOIN departments d
WHERE department_id = 50;

-- 'Seattle'에 근무하는 사번, 이름, 부서이름, 도시
SELECT e.employee_id, e.first_name, d.department_name, l.city
FROM employees e, departments d, locations l
WHERE e.department_id = d.department_id
and d.location_id = l.location_id
and l.city = 'Seattle';

--조인 테이블이 3개 이상일 경우
SELECT e.employee_id, e.first_name, d.department_name, l.city
FROM employees e 
    JOIN departments d
        ON e.department_id = d.department_id
    JOIN locations l
        ON d.location_id = l.location_id
WHERE l.city = 'Seattle';

--outer join
--모든 사원의 사번, 이름, 부서번호, 부서이름

SELECT e.employee_id, e.first_name, d.department_id, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id(+);

SELECT e.employee_id, e.first_name, d.department_id, nvl(d.department_name, '대기발령중')
FROM employees e LEFT OUTER JOIN departments d
ON e.department_id = d.department_id;

--모든 부서의 근무하는 사원의 사번, 이름(사원없음), 부서번호, 부서이름
SELECT e.employee_id, nvl(e.first_name, '사원없음'), d.department_id, d.department_name
FROM employees e, departments d
WHERE e.department_id(+) = d.department_id;

SELECT e.employee_id, nvl(e.first_name, '사원없음'), d.department_id, d.department_name
FROM employees e RIGHT OUTER JOIN departments d
ON e.department_id = d.department_id;


--모든 부서에 모든 사원의 근무하는 사원의 사번, 이름(사원없음), 부서번호, 부서이름

SELECT  e.employee_id, 
        nvl(e.first_name, '사원없음'), 
        d.department_id, 
        nvl(d.department_name, '대기발령중')
        
FROM employees e, departments d
WHERE e.department_id(+) = d.department_id
AND e.department_id = d.department_id(+); --안댐

SELECT  e.employee_id, 
        nvl(e.first_name, '사원없음'), 
        d.department_id, 
        nvl(d.department_name, '대기발령중')
        
FROM employees e FULL OUTER JOIN departments d

ON e.department_id = d.department_id;

--모든 부서에 모든 사원의 근무하는 사원의 사번, 이름(사원없음), 부서번호, 부서이름
SELECT  e.employee_id, 
        nvl(e.first_name, '사원없음'), 
        d.department_id, 
        nvl(d.department_name, '대기발령중')
        
FROM employees e FULL OUTER JOIN departments d

ON e.department_id = d.department_id;

--권영찬 0227
--테이블에 존재하는 모든 나라와 대륙을 출력(대륙은 중복해서 나와도 됨)
--나라, 대륙
SELECT c.country_name, r.region_name
FROM countries c FULL OUTER JOIN regions r
ON c.region_id = r.region_id;
select *
from regions;

--부서장이 일하고 있는 지역이름  
--부서장 이름, 부서이름, 지역이름(없을 경우 '부서장없음')
SELECT nvl(e.first_name, '부서장 없음'), d.department_name, l.city
FROM departments d, employees e, locations l
WHERE d.manager_id = e.employee_id(+)
AND d.location_id = l.location_id;

--순위구하는 함수
--사원의 급여순위
SELECT first_name, rank() over (ORDER BY salary) 
FROM employees;
--숫자밀림방지
SELECT first_name, salary, dense_rank() over (ORDER BY salary DESC)
FROM employees;
--그룹지어 순위를 구할때
--사원의 부서별 급여 순위
SELECT first_name, rank() over (partition BY department_id ORDER BY salary)
FROM employees;

--주석입니다
SELECT * FROM employees;
--사번, 이름, 부서이름, 급여, 부서원들의 평균급여, 부서내 급여 순위, 전체급여순위로 내림차순정렬

SELECT e.employee_id, e.first_name, e.salary, d.department_id
FROM employees e, departments d
WHERE e.department_id = d.department_id(+);

SELECT avg(salary), e.department_id
FROM employees e, departments d
WHERE e.department_id = d.department_id
GROUP BY e.department_id;

SELECT avg(salary)
FROM employees
WHERE department_id = e.department_id;

SELECT  e.employee_id, e.first_name, d.department_name, e.salary, ROUND((SELECT avg(salary)
                                                        FROM employees
                                                        WHERE department_id = e.department_id)) "부서원 평균 급여",
        rank() over (partition by e.department_id order by salary DESC) "부서내 급여 순위"
FROM employees e, departments d
WHERE e.department_id = d.department_id
ORDER BY salary DESC;

-- 부서번호가 50이거나, 90인 사원과
-- 급여가 10000이상인 사원
-- 사번, 이름, 급여, 부서번호
-- db에 연결했다 끊는 작업이 크다
SELECT *
FROM employees;

-- union 중복 제거
SELECT employee_id, first_name, salary, department_id
FROM employees
WHERE department_id in (50, 90)
union 
SELECT employee_id, first_name, salary, department_id
FROM employees
WHERE salary > 10000;

-- union 중복 제거 x
SELECT employee_id, first_name, salary, department_id
FROM employees
WHERE department_id in (50, 90)
union all
SELECT employee_id, first_name, salary, department_id
FROM employees
WHERE salary > 10000;

-- INTERSECT 교집합을 구함
SELECT employee_id, first_name, salary, department_id
FROM employees
WHERE department_id in (50, 90)
intersect
SELECT employee_id, first_name, salary, department_id
FROM employees
WHERE salary > 10000;

-- MINUS
SELECT employee_id, first_name, salary, department_id
FROM employees
WHERE department_id in (50, 90)
MINUS
SELECT employee_id, first_name, salary, department_id
FROM employees
WHERE salary > 10000;

-- 부서별 급여총합, 평균급여, 사원수, 최대급여, 최소급여
-- 그룹핑을 한 컬럼과, 그룹함수는 쓸수 있다
SELECT  nvl(d.department_name, '부서없음') "부서이름", 
        sum(e.salary) 총합, 
        round(avg(e.salary), 2) 평균급여, 
        count(e.employee_id) 사원수, 
        max(e.salary) 최대급여, 
        min(e.salary) 최소급여
FROM employees e, departments d
WHERE e.department_id = d.department_id (+)
GROUP BY nvl(d.department_name, '부서없음');

-- 부서별 급여총합, 평균급여, 사원수, 최대급여, 최소급여
-- 평균급여가 5000이하인 부서
SELECT  nvl(d.department_name, '부서없음') "부서이름", 
        sum(e.salary) 총합, 
        round(avg(e.salary), 2) 평균급여, 
        count(e.employee_id) 사원수, 
        max(e.salary) 최대급여, 
        min(e.salary) 최소급여
FROM employees e, departments d
WHERE e.department_id = d.department_id (+)
GROUP BY nvl(d.department_name, '부서없음')
having round(avg(e.salary), 2) <= 5000;

-- 각 부서별 평균 급여보다 많이 받는
-- 사번, 이름, 급여

SELECT employee_id, first_name, salary
FROM employees
WHERE salary >  all(SELECT avg(salary) 
                    FROM employees 
                    GROUP BY department_id);
                    
-- 자신의 부서 평균 급여보다 많이 받는
-- 사번, 이름, 급여
SELECT e.employee_id, e.first_name, e.salary
FROM employees e,   (SELECT department_id, avg(salary) asal 
                    FROM employees 
                    GROUP BY department_id) d
WHERE e.department_id = d.department_id
AND d.asal > e.salary;

-- 부서별 최고 급여를 받는 사원의
-- 부서이름, 사번, 이름, 급여

SELECT d.department_name, e.employee_id, e.first_name, e.salary
FROM employees e, departments d,    (SELECT department_id, max(salary) msal 
                                    FROM employees 
                                    GROUP BY department_id) ms
WHERE e.department_id = d.department_id
AND e.department_id = ms.department_id
AND e.salary = ms.msal;

-- 이거랑 위는 다르다
SELECT d.department_name, e.employee_id, e.first_name, e.salary
FROM employees e, departments d
WHERE e.department_id = d.department_id
AND e.salary in (SELECT max(salary) msal 
                FROM employees 
                GROUP BY department_id);
-- 부서별 최고 급여를 받는 사원의
-- 부서이름, 사번, 이름, 급여

SELECT d.department_name, e.employee_id, e.first_name, e.salary
FROM employees e,   (SELECT department_id, max(salary) msal
                    FROM employees
                    GROUP BY department_id) m, departments d
WHERE e.department_id = m.department_id
AND e.department_id = d.department_id
AND e.salary = m.msal;

-- rownum 행번호!!
-- 크다 비교는 불가
-- rownum 이 SELECT 절에 꼭 와야하는건 아니다
SELECT rownum, employee_id, salary
FROM employees
ORDER BY salary desc;

SELECT rownum, employee_id, salary
FROM employees
WHERE rownum < 12
ORDER BY salary desc;

SELECT rownum, employee_id, salary
FROM employees
WHERE rownum between 5 and 10;

--TOP N query
-- 순위, 사번, 이름, 급여, 입사년대, 부서이름, 
-- 급여순 순위, 
-- 한 페이지당 5명씩 출력
-- 2page 출력
-- 1980년대, 1990년대, 2000년대

SELECT  base2.*

FROM    (SELECT rownum rnum, base1.*

        FROM    (SELECT e.employee_id employee_id,
                        e.first_name first_name, 
                        e.salary salary, 
                        concat(trunc(to_char(e.hire_date, 'yyyy'),-1), '년대') "입사년대", 
                        d.department_name department_name
                FROM employees e, departments d 
                WHERE e.department_id = d.department_id(+)
                ORDER BY salary DESC) base1
                
        WHERE rownum <= (&a * 5)) base2
        
WHERE rnum >= (&a * 5) - 4; -- rnum >= (&a * 5) - 5 이게 더 낫다

--튜닝
SELECT  rnum, employee_id, first_name, salary, concat(trunc(to_char(hire_date, 'yyyy'),-1), '년대') "입사년대", department_name

FROM    (SELECT rownum rnum, base1.*

        FROM    (SELECT employee_id,
                        first_name, 
                        salary,  
                        hire_date,
                        department_id
                FROM employees
                ORDER BY salary DESC) base1
                
        WHERE rownum <= (&a * 5)) base2, departments d
        
WHERE rnum >= (&a * 5) - 4
AND base2.department_id = d.department_id(+)
ORDER BY rnum;

-- 1 1-5  2 6-10  3   11-15
--  1페이지당 5명 뿌려라
-- (&a * 5) - 4  -> 제일 작은 랭크
-- &a * 5 -> 제일 큰 랭크

-- rank() over()
SELECT t.rnum, t.employee_id, t.first_name, t.salary, concat(trunc(to_char(t.hire_date, 'yyyy'), -1), '년대')
FROM    (SELECT rank() over(ORDER BY salary DESC) rnum, employee_id, first_name, salary, hire_date
        FROM employees) t
WHERE t.rnum <= (&a * 5) and t.rnum > (&a * 5) - 5;

-- 사번, 이름, 부서번호, 직원유형
-- 부서번호 60이면 개발자, 
-- 90이면 임원진
-- 나머지 비개발자

SELECT  employee_id, first_name, department_id, 
    case
        when department_id = 60
        then '개발자'
        when department_id = 90
        then '임원진'
        else '비개발자'
    end 직원유형
FROM    employees;

SELECT  employee_id, 
        first_name, 
        department_id,
        decode(department_id, 60, '개발자', 90, '임원진', '비개발자') -- equal 비교만 가능
FROM    employees;

--그룹함수
--회사의 총사원수, 급여 총합, 급여 평균, 최고급여, 최저급여
SELECT count(employee_id), sum(salary), avg(salary), max(salary), min(salary)
FROM employees;

--평균급여보다 많이 받는 사원의 사번, 이름, 급여
SELECT employee_id, first_name, salary
FROM employees
WHERE salary > (SELECT avg(salary) FROM employees);

SELECT 
    case 
        when salary > avg(salary)
        then employee_id
    end 사번,
    case 
        when salary > avg(salary)
        then first_name
    end 이름,
    case 
        when salary > avg(salary)
        then salary
    end 급여
FROM employees; --요거 안되네

--사번, 이름, 부서번호, 부서이름
SELECT employee_id, first_name, department_id, department_name
FROM employees;

--JOIN
--n-1개의 조인조건을 걸어야한다 (n은 조인할 테이블의 갯수)

SELECT * 
FROM employees, departments
WHERE employees.department_id = departments.department_id;
--관계를 맺고 있는 컬럼으로 join 해야한다
--기본키는 유일성과 not null 특성을 가지고있다
--외래키

--테이블에도 별칭을 줄수 있다
SELECT e.employee_id, e.first_name, e.department_id, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.department_id;

--'seattle'에 근무하는 사원의 사번, 이름, 부서이름, 도시이름

SELECT e.employee_id, e.first_name, d.department_name, l.city
FROM employees e, departments d, locations l
WHERE lower(l.city) = lower('seattle') 
and e.department_id = d.department_id
and d.location_id = l.location_id;

--'asia'에 근무하는 사원 이름 부서이름 도시이름
SELECT  e.employee_id, e.first_name, d.department_id, d.department_name, l.city

FROM    employees e, departments d, locations l, countries c, regions r

WHERE   lower(r.region_name) = lower('asia')
and     e.department_id = d.department_id 
and     d.location_id = l.location_id
and     l.country_id = c.country_id
and     c.region_id = r.region_id;

--catesian product
--cross join

--equi join(natural join)ansi

--10,80,90번 부서에 근무중인 사원의
--사번, 이름, 직책이름, 부서이름

SELECT e.employee_id, e.first_name, e.job_id, d.department_name
FROM employees e, departments d
WHERE e.department_id in(10, 80, 90)
and e.department_id = d.department_id;


--직책아이디가 'SA_REP'인 사원의
--사번, 이름, 직책이름, 부서이름
--단, 부서가 없는 경우 '대기발령'으로 출력

SELECT e.employee_id, first_name, e.job_id, nvl(d.department_name, '대기발령')
FROM employees e, departments d
WHERE lower(e.job_id) = lower('SA_REP')
and e.department_id = d.department_id(+);

--사번이 200인 사원의 근무 이력, 

--사번, 이름, 직책이름, 부서이름, 근무개월수 소수둘째
SELECT *
FROM job_history;
--문제를 해결할땐 잘 생각해보고 하자
SELECT  e.employee_id, e.first_name, j.job_title, d.department_name, 
        to_char(round(months_between(jh.end_date, jh.start_date), 2),'999.99')
FROM employees e, job_history jh, departments d, jobs j
WHERE jh.employee_id = 200
and e.employee_id = jh.employee_id
and jh.department_id = d.department_id
and jh.job_id = j.job_id;

SELECT to_date('2000/02/02') - to_date('2000/01/01')
FROM dual;

--모든 사원의 부서이름, 사번, 이름, 매니저사번, 매니저이름
SELECT d.department_name, e.first_name, e.manager_id, m.first_name
FROM employees e, departments d, employees m
WHERE e.department_id = d.department_id
and e.manager_id = m.employee_id;


SELECT e.first_name, m.first_name FROM employees e ,employees m
WHERE e.manager_id = m.employee_id;

SELECT * FROM employees;
-- 'canada'에서 근무하는 사원들의 매니져들의 급여평균을 구하시오
-- 예시 -> 급여평균
            145,000
SELECT avg(m.salary) "급여평균"
FROM countries c, locations l, departments d, employees e, employees m
WHERE lower(c.country_name) = lower('canada')
and c.country_id = l.country_id
and l.location_id = d.location_id
and d.department_id = e.department_id
and e.manager_id = m.employee_id;

-- first_name에 e가 들어가는 사원들의 매니져들 중에서 급여가 10000이상인 사람들의 급여 합계를 구하시오

SELECT sum(m.salary)
FROM employees e, employees m
WHERE e.first_name like '%e%'
and e.manager_id = m.employee_id
and m.salary >= 10000;
